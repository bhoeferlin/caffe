#ifndef CLASSIFIER_HEADER__
#define CLASSIFIER_HEADER__

#include <opencv2/opencv.hpp>

#include <algorithm>
#include <iosfwd>
#include <memory>
#include <string>
#include <utility>
#include <vector>
#include <functional>

#include <caffe/caffe.hpp>

/*
#pragma comment(lib, "opencv_core310.lib")
#pragma comment(lib, "opencv_highgui310.lib")
#pragma comment(lib, "opencv_imgproc310.lib")
#pragma comment(lib, "opencv_imgcodecs310.lib")
*/

#pragma comment(lib, "cudart.lib")
#pragma comment(lib, "cuda.lib")
#pragma comment(lib, "nppi.lib")
#pragma comment(lib, "cufft.lib")
#pragma comment(lib, "cublas.lib")
#pragma comment(lib, "curand.lib")
#pragma comment(lib, "libopenblas.lib")
#pragma comment(lib, "libhdf5.lib")
#pragma comment(lib, "libhdf5_cpp.lib")
#pragma comment(lib, "libhdf5_hl.lib")
#pragma comment(lib, "libhdf5_hl_cpp.lib")
#pragma comment(lib, "libhdf5_tools.lib")
#pragma comment(lib, "libglog_static.lib")
#pragma comment(lib, "shlwapi.lib")
#pragma comment(lib, "gflags.lib")

#ifdef USE_CUDNN
#   pragma comment(lib, "cudnn.lib") 
#endif

#ifdef _DEBUG
#   pragma comment(lib, "libprotobufd.lib")
#   pragma comment(lib, "libprotocd.lib")
#else
#   pragma comment(lib, "libprotobuf.lib")
#   pragma comment(lib, "libprotoc.lib")
#endif


/* Pair (label, confidence) representing a prediction. */
typedef std::pair< int, float > Prediction;

class Classifier
{
public:

    static const std::string RETRAIN_SNAPSHOTPATH_PLACEHOLDER;
    static const std::string RETRAIN_MODELPATH_PLACEHOLDER; 
    static const std::string RETRAIN_TRAINDATAPATH_PLACEHOLDER;
    static const std::string RETRAIN_VALIDDATAPATH_PLACEHOLDER;


    Classifier( bool useGPU, 
                const std::string& model_file,
                const std::string& trained_file,
                const std::string& mean_file,
                const std::vector< int >& outputLabelAssignment );

    Classifier( bool useGPU, 
                const std::string& model_file,
                const std::string& trained_file,
                const cv::Scalar& meanPerChannel,
                const std::vector< int >& outputLabelAssignment );
        
    // Return the top N predictions.
    std::vector< Prediction > classify( const cv::Mat& img, int n = 5 );

    // Load the mean file in binaryproto format.
    static cv::Scalar GetMean( const std::string& mean_file, const unsigned int& num_channels );


    /**
    * @brief Retrains this classifier based on the provided data.
    * @param trainingAndValidationData - vector of image/label pairs. The label will be reversely mapped to the
    *                                    output by the outputLabelAssignment vector provided in the constructor.
    *                                    If train and validation data is provided by the dataset (e.g. by setting the ratio),
    *                                    this split of the data will be used, otherwise train and validation data will be 
    *                                    generated by using half of the set for training and half of the set as validation data.
    * @param imgDimensions             - the original image dimensions to restore the image from the feature vector.
    * @param numberOfTrainIteration    - number of iterations the classifier is retrained with the provided data.
    * @param progressUpdate            - function callback to set progress update information from training, update info reaches from 0..1
    * @param snapshotUpdate            - function callback to set snapshot information
    * @param solver_file               - path to solver file used for retrain. This file requires to have a placeholder (%retrainModelPath%)
    *                                    to allow substitution of the current retrain model.
    * @param model_file                - path to the retrain model file. This file requires to have placeholders (%trainAnnotationPath%, %validAnnotationPath%)
    *                                    to allow substitution of the current train and test data.
    * @param trained_file              - path to the weights file used to start retrain with.
    * @param folderToStoreData         - folder used to store all (temporary) data files. If argument is an empty string, 
    *                                    the folder c:/tmp_train is used. 
    */ // TODO require min improvement?!?
    void retrain( const cv::Ptr< cv::ml::TrainData >& trainingAndValidationData, 
                  const cv::Size2i& imgDimensions, 
                  unsigned int numberOfTrainIterations,
                  std::function<void(float)> progressUpdate,
                  std::function<void(unsigned int, float, float, const std::string&)> snapshotUpdate,
                  const std::string& solver_file,
                  const std::string& model_file,
                  const std::string& trained_file,
                  const std::string& folderToStoreData = "" );


    static bool GoogleLoggingInitialized;
    static bool InitializeGoogleLogging();

private:

    void init( bool useGPU, 
               const std::string& model_file,
               const std::string& trained_file,
               const std::vector< int >& outputLabelAssignment );


    void createMeanImage( const cv::Scalar& channel_mean );
    
    std::vector< float > predict( const cv::Mat& img );

    /** Wrap the input layer of the network in separate cv::Mat objects
     * (one per channel). This way we save one memcpy operation and we
     * don't need to rely on cudaMemcpy2D. The last preprocessing
     * operation will write the separate channels directly to the input
     * layer. 
     */
    void wrapInputLayer( std::vector< cv::Mat >* input_channels );

    void preprocess( const cv::Mat& img,
                     std::vector<cv::Mat>* input_channels );

    static unsigned int ReplaceAllPlaceholdersInTextFile( const std::string& filename, const std::string& from, const std::string& to );

    template<typename Dtype> 
    class SolverCallback : public caffe::Solver<Dtype>::Callback
    {
    public:
        SolverCallback( const Classifier* parentInstance, std::function<void(float)> progressUpdate,  std::function<void(unsigned int, float, float, const std::string&)> snapshotUpdate ) 
            : m_parentInstance( parentInstance ), m_progressUpdate( progressUpdate ), m_snapshotUpdate( snapshotUpdate )
        {};

    protected:
        void on_start() {};
        void on_gradients_ready() {};
        void on_iteration_finished( float progress ) 
        { 
            assert( progress >= 0 && progress <= 1.0 );
            m_progressUpdate( progress); 
        };
        void on_snapshot_saved( unsigned int iteration, float loss, float accuracy, const std::string& filename ) 
        {
            m_snapshotUpdate( iteration, loss, accuracy, filename );
        };

    private:
        const Classifier* m_parentInstance;
        std::function<void(float)> m_progressUpdate;
        std::function<void(unsigned int, float, float, const std::string&)> m_snapshotUpdate;
    };
        
 private:

    std::shared_ptr< caffe::Net<float> > m_net;
    cv::Size m_input_geometry;
    int m_num_channels;
    cv::Mat m_mean; 

    std::vector< int > m_outputLabelAssignment;
};

#endif // CLASSIFIER_HEADER__